## 스트림으로 데이터 수집

- Collectors 클래스로 컬렉션 만들고 사용하기
- 하나의 값으로 데이터 스트림 리듀스 하기
- 특별한 리듀싱 요약 연산
- 데이터 그룹화와 분할
- 자신만의 커스텀 컬렉터 개발

> 컬렉션(Collection), 컬렉터(Collector), collect는 서로 다르다.

## 컬렉터란 무엇인가?

Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다.

> 스트림에 collect를 호출하면 스트림의 요소에(컬렉터로 파라미터화된) 리듀싱 연산이 수행된다. 즉, 내부적으로 `리듀싱 연산`이 일어난다.


Collectors에서 제공하는 메서드의 기능은 크게 세 가지로 구분할 수 있다.

- 스트림 요소를 하나의 값으로 리듀스하고 요약
- 요소 그룹화
- 요소 분할

## reducing

범용 Collectors.reducing을 사용

```java
int totalCalories = menu.stream()
  .collect(reducing(0, Dish::getCaloreis, (i, j) -> i + j));
```

reducing은 세 개의 인수를 받는다. (초기값, 합계 함수, 변환 함수)

- 첫 번째 인수는 리듀싱 연산의 시작값이거나 스트림에 인수가 없을 때는 반환값이다.(숫자 합계에서는 인수가 없을 때 반환하므로 0이 적합하다.)
- 두 번째 인수는 함수를 받는다.
- 세 번째 인수는 같은 종류의 두 항목을 하나의 값으로 더하는 BinaryOperator이다.

### 한 개의 인수를 갖는 reducing

가장 칼로리가 높은 요리 찾는 방법

```java
Optional<Dish> mostCaloireDish = menu.stream().collect(reducing((d1, d2) -> d1.getCaloreis() > d2.getCalories() ? d1 : d2));
```

한 개의 인수를 갖는 reducing 팩터리 메서드는 세 개의 인수를 갖는 reducing 메서드에서 첫 번째 인수를 받고, 두 번째 인수에서 
`자기 자신을 그대로 반환하는 항등함수(identity function)`를 두 번째 인수로 받는 상황에 해당한다.

따라서 한 개의 인수를 갖는 reducing 컬렉터는 시작값이 없으므로 빈 스트림이 넘겨졌으래 시작값이 설정되지 않아 null을 반환할 수 있으므로
Optional 객체로 만들어 사용해야 한다.

### 컬렉션 프레임워크 유연성 : 같은 연산도 다양한 방식으로 수행할 수 있다.

```java
int totalCaloires = menu.stream().collect(reducing(0, Dish::getCaloires, Integer::sum));
```
