# 람다 표현식

## 람다란?

람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것.

람다 표현식은 `파라미터 + 화살표 + 바디`로 이루어진다.

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

## 자바8에서 지원하는 다섯 가지 람다 표현식 예제

```java
(String s) -> s.length() // String 형식의 파라미터를 받으며, int 반환 람다 표현식에는 return 문이 함축되어있어서 명시하지 않아도 된다.
(Apple a) -> a.getWeight() > 150 // Apple 형식의 파라미터를 받으며, boolean 반환
(int x, int y) -> {
  System.out.println("Result : ");
  System.out.println(x+y);
}
// int 형식의 파라미터 두 개를 가지며 리턴 값이 없다.

() -> 42 // 파라미터가 없으며 42를 반환한다.

(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

- 람다의 기본 문법

`(parameteres) -> expression`

`(parameteres) -> { statements; }`


람다에서 표현식이 하나인데 return문을 사용하는 경우 블록으로 감싸야 한다. 

```java
// x
(String s) -> return "Alan" + i;
// o
(String s) -> {return "Alan" + i;}
```

## 함수형 인터페이스

함수형 인터페이스는 `오직 하나의 추상메서드만 지정하는 인터페이스` 이다. 예를들어 `Predicate<T>`, Comparator, Runnable 등이 있다.

```java
public interface Predicate<T> {
  boolean Test (T t);
}

public interface Comparator<T> {
  int compare(T o1, T o2);
}

public interface Runnable {
  void run();
}

public interface ActionListener extends EventListener {
  void actionPerformed(ActionEvent e);
}

public interface Callable<V> {
  V call() throws Exception;
}

public interface PrivilegedAction<T> {
  T run();
}
```

람다에서 함수형 인터페이스로 뭘 할 수 있을 까?  람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 `전체 표현식을
함수형 인터페이스의 인스턴스로 취급(기술적으로 따지면 함수형 인터페이스를 `구현한` 클래스의 인스턴스)` 할 수 있다.

## 함수 디스크립터(function descriptor)

함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 `함수 디스크립터`라고 부른다.
예를들어 Runnable 인터페이스의 유잃ㄴ 추상 메서드 run은 인수와 반환값이 없으므로 void 반환 `() -> void`로 표기할 수 있다.

람다 표현식은 `함수형 인터페이스`를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있다. 

그리고 void 반환이 한 개 인 경우에는 중괄호로 감쌀 필요가 없다.

## @FunctionallInterface

@FunctionallInterface는 함수형 인터페이스에 붙는 어노테이션이다. (즉, 함수형 인터페이스를 가리키는 어노테이션)

@FunctionallInterface로 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다. 예를 들어 추상 메서드가 한 개 이상이라면

`Multiple nonoverriding abstract methods found in interface Foo` 같은 에러가 발생할 수 있다.
