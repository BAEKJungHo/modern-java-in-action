# 람다 표현식

## 람다란?

람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것.

람다 표현식은 `파라미터 + 화살표 + 바디`로 이루어진다.

```java
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

## 자바8에서 지원하는 다섯 가지 람다 표현식 예제

```java
(String s) -> s.length() // String 형식의 파라미터를 받으며, int 반환 람다 표현식에는 return 문이 함축되어있어서 명시하지 않아도 된다.
(Apple a) -> a.getWeight() > 150 // Apple 형식의 파라미터를 받으며, boolean 반환
(int x, int y) -> {
  System.out.println("Result : ");
  System.out.println(x+y);
}
// int 형식의 파라미터 두 개를 가지며 리턴 값이 없다.

() -> 42 // 파라미터가 없으며 42를 반환한다.

(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

- 람다의 기본 문법

`(parameteres) -> expression`

`(parameteres) -> { statements; }`


람다에서 표현식이 하나인데 return문을 사용하는 경우 블록으로 감싸야 한다. 

```java
// x
(String s) -> return "Alan" + i;
// o
(String s) -> {return "Alan" + i;}
```

## 함수형 인터페이스

함수형 인터페이스는 `오직 하나의 추상메서드만 지정하는 인터페이스` 이다. 예를들어 `Predicate<T>`, Comparator, Runnable 등이 있다.

```java
public interface Predicate<T> {
  boolean Test (T t);
}

public interface Comparator<T> {
  int compare(T o1, T o2);
}

public interface Runnable {
  void run();
}

public interface ActionListener extends EventListener {
  void actionPerformed(ActionEvent e);
}

public interface Callable<V> {
  V call() throws Exception;
}

public interface PrivilegedAction<T> {
  T run();
}
```

람다에서 함수형 인터페이스로 뭘 할 수 있을 까?  람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 `전체 표현식을
함수형 인터페이스의 인스턴스로 취급(기술적으로 따지면 함수형 인터페이스를 `구현한` 클래스의 인스턴스)` 할 수 있다.

## 함수 디스크립터(function descriptor)

함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다. 람다 표현식의 시그니처를 서술하는 메서드를 `함수 디스크립터`라고 부른다.
예를들어 Runnable 인터페이스의 유일한 추상 메서드 run은 인수와 반환값이 없으므로 void 반환 `() -> void`로 표기할 수 있다.

람다 표현식은 `함수형 인터페이스`를 인수로 받는 메서드에만 람다 표현식을 사용할 수 있다. 

그리고 void 반환이 한 개 인 경우에는 중괄호로 감쌀 필요가 없다.

## @FunctionallInterface

@FunctionallInterface는 함수형 인터페이스에 붙는 어노테이션이다. (즉, 함수형 인터페이스를 가리키는 어노테이션)

@FunctionallInterface로 선언했지만 실제로 함수형 인터페이스가 아니면 컴파일러가 에러를 발생시킨다. 예를 들어 추상 메서드가 한 개 이상이라면

`Multiple nonoverriding abstract methods found in interface Foo` 같은 에러가 발생할 수 있다.

## 람다 활용 : 실행 어라운드 패턴 

자원 처리(예를 들면 데이터베이스의 파일 처리)에 사용하는 `순환 패턴(recurrent pattern)`은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어 진다. 설정(setup)과 정리(cleanup) 과정은 대부분 비슷하다. 즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태를 갖는다.

- `실행 어라운드 패턴(execute around pattern)`

```java
public String processFile() throws IOException {
  try ( BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    return br.readLine();
  }
}
```

try-with-resources 구문을 사용하여 자원을 닫지 않아도 된다.

### 1단계 : 동작(메서드) 파라미터화를 기억하라

현재 코드는 파일에서 한 번에 한 줄만 읽을 수 있다. 만약 한 번에 두 줄을 읽거나 가장 자주 사용되는 단어를 반환하려면 어떻게 해야 할까?

바로 processFile()을 동작 파라미터화 시키는 것이다.

- 한 번에 두 줄 출력

```java
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```

### 2단계 : 함수형 인터페이스를 이용해서 동작 전달 

함수형 인터페이스 자리에 람다를 사용할 수 있다. 따라서 BufferedReader -> Strin 과 IOException을 던질(throw) 수 있는 시그니처와 일치하는 함수형 인터페이스를 만들어야 한다. 이 인터페이스를 BufferedReaderProcessor라고 정의하자

```java
@FunctionalInterface
public interface BufferedReaderProcessor {
  String process(BufferedReader b) throws IOException;
}
```

```java
public String processFile(BufferedReaderProcessor p) throws IOException {
  // ...
}
```
