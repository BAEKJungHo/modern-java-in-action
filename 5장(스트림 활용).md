# 스트림 활용

## 필터링

### 프레이케이트로 필터링

filter 메서드는 `프레디케이트(불리언을 반환하는 함수)`를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.

```java
List<Dish< vegetarianMenu = menu.stream()
  .filter(Dish::isVegetarian) 
  .collect(toList());
```

### 고유 요소 필터링

스트림은 고유 요소로 이루어진 스트림을 반환하는 `distinct(중복 제거)` 메서드도 지원한다.(고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정된다.)

- 리스트의 모든 짝수를 선택하고 중복을 필터링 한다.

```java
List<Integer> numbers = Arrays.asList<1, 2, 1, 3, 3, 2, 4);
numbers.stream()
  .filter(i -> i % 2 == 0)
  .distinct()
  .forEach(System.out::println);
```

## 스트림 슬라이싱(자바 9)

스트림 슬라이싱은 자바 9에서 도입된 새 기술이며, 스트림 슬라이싱을 이용하면 아래와 같은 이점을 누릴 수 있다.

- 프레디케이트를 이용하는 방법
- 스트림의 요소를 선택하거나 스킵하는 다양한 방법
- 스트림의 처음 몇 개의 요소를 무시하는 방법
- 특정 크기로 스트림을 줄이는 방법

### 프레디케이트를 이용한 슬라이싱

자바 9는 스트림의 요소를 효과적으로 선택할 수 있도록 `takeWhile, dropWhile` 두 가지 새로운 메서드를 지원한다.

```java
List<Dish> specialMenu = Arrray.asList(
  new Dish("seasonal fruit", true, 12, Dish.Type.OTHER),
  new Dish("prawns", false, 300, Dish.Type.FISH),
  new Dish("rice", true, 350, Dish.Type.OTHER),
  ...
);
```

위 리스트는 이미 칼로리 순으로 정렬되어 있다. 

만약 320 칼로리 이하의 요리를 선택하려면 filter가 떠오를 것이다.

따라서 320 칼로리보다 크거나 같은 요리가 나왔을 때 반복작업을 중단 할 수 있는데, `takeWhile` 을 사용하면된다.

아주 많은 요소를 포함하는 큰 스트림에서는 이 차이가 상당히 커질 수 있다.

```java
List<Dish> slicedMenu1
  = specialMenu.stream()
    .takeWhile(dish -> dish.getCalories() < 320)
    .collect(toList());
```

만약 나머지 요소(320 칼로리보다 큰 것들)를 선택하려면 `dropWhile`을 이용하면 된다. dropWhile은 프레디케이트가 처음으로 거짓이 되는 지점까지
발견된 요소를 버린다.

```java
List<Dish> slicedMenu2
  = specialMenu.stream()
    .dropWhile(dish -> dish.getCalories() < 320)
    .collect(toList());
```

### 스트림 축소

스트림은 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 `limit(n)` 메서드를 지원한다.

### 요소 건너뛰기

스트림은 `처음 n개 요소를 제외한 스트림을 반환`하는 `skip(n)` 메서드를 지원한다. n개 이하의 요소를 포함하는 스트림에 skip(n)을 호출하면 빈 
스트림이 반환된다.

## 매핑

스트림 API의 map과 flatMap 메서드는 특정 데이터를 선택하는 기능을 제공한다. (`특정 객체에서 특정 데이터를 선택하는 작업`)

> map과 flatMap은 변환에 가까운 매핑

### 스트림의 각 요소에 함수 적용하기

스트림은 함수를 인수로 받는 map 메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다.
(이 과정은 기존 값을 고친다(modify) 라는 개념보다는 `새로운 버전을 만든다` 개념에 가까우므로 `변환(transforming)에 가까운 매핑(mapping)`이라는 
단어를 사용한다.)

- 요리명 추출

```java
List<String> dishNames = menu.stream()
  .map(Dish::getName)
  .collect(toList());
```

### flatMap

flatMap은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다. 즉, `하나의 평면화된 스트림을 반환`한다.

```java
List<String> uniqueCharacters = 
  words.stream()
    .map(word -> word.splict("")) // 각 단어를 개별 문자를 포함하는 배열로 반환
    .flatMap(Arrays::stream) // 생성된 스트림을 하나의 스트림으로 평면화
    .distinct()
    .collect(toList());
```

- 숫자 1 2 3 4 5가 제공되면 해당 숫자의 제곱근을 반환 1 4 9 16 25

```java
List<Integer> numbers = Arrays.asList(1,2,3,4,5);
List<Integer> squars = numbers.stream()
  .map(n -> n * n)
  .collect(toList());
```

- 두 개의 숫자 리스트 1,2,3과 3,4 가 있을때 모든 숫자 쌍의 리스트를 반환 하시오 (1,3) (1,4) (2,3) ...

```java
List<Integer> numbers1 = Arrays.asList(1, 2, 3);
List<Integer> numbers2 = Arrays.asList(3, 4);
List<int[]> pairs = numbers1.stream()
  .flatMap(i -> numbers2.stream().map(j -> new int[]{i, j}))
  .collect(toList());
```

## 검색과 매칭

### 프레디케이트가 적어도 한 요소와 일치하는지 확인

- anyMatch 메서드 사용

```java
if(menu.stream().anyMatch(Dish::isVegetarian)) {
  System.out.println("The menu is somewhat vegetarian friendly!!");
}
```

### 프레디케이트가 모든 요소와 일치하는지 검사

- allMatch 메서드 사용

```java
boolean isHealthy = menu.stream().allMatch(dish -> dish.getCalories() < 1000);
```

### 프레디케이트가 모든 요소와 일치하지 않는 경우를 검사

- noneMatch 메서드 사용

```java
boolean isHealthy = menu.stream().noneMatch(dish -> dish.getCalories() >= 1000);
```

> anyMatch, allMatch, noneMatch 세 메서드는 스트림 `쇼트서킷` 기법, 즉 자바의 &&, ||와 같은 연산을 활용한다.

## 쇼트서킷(short circuit)

예를 들어 여러 and 연산으로 연결된 커다란 불리언 표현식을 평가한다고 가정하자. 표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와
상관없이 전체 결과도 거짓이 된다. 이러한 상황을 쇼트서킷이라고 부른다. 스트림의 allMatch, noneMatch, findFirst, findAny, limit 등의 연산은
모든 스트림의 요소를 처리하지 않고도 반환할 수 있다. 즉, 원하는 요소를찾았으면 즉시 결과를 반환할 수 있다.

### 요소검색

- findAny
  - 스트림에서 임의의 요소를 반환한다.
  
```java
Optional<Dish> dish = menu.stream()
  .filter(Dish::isVegetarian)
  .findAny();
```

